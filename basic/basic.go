package basic

import (
	"fmt"
	"image"
	"image/color"
	"image/png"
	"log"
	"math"
	"os"
)

var pi float32 = 3.14159

func Basic() {
	simple()
	variable()
	types()
	sinImg()
}

func simple() {
	fmt.Println("==================== simple ====================")
	/*
		声明：
		Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。
		这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：int* a1, b1; 。其中只有 a1 是指针而 b1 不是。
	*/
	//var a, b *int // 将它们都声明为指针类型

	/*
		Go语言的基本类型有：
		bool
		string
		int、int8、int16、int32、int64
		uint、uint8、uint16、uint32、uint64、uintptr
		byte // uint8 的别名
		rune // int32 的别名 代表一个 Unicode 码
		float32、float64
		complex64、complex128
	*/

	/*
		当一个变量被声明之后，系统自动赋予它该类型的零值：
		int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。
		所有的内存在 Go 中都是经过初始化的。
	*/

	/*
		变量的命名规则遵循骆驼命名法

		声明：
		1.
		var 变量名 变量类型
		2.
		var (
		    a int
		    b string
		    c []float32
		    d func() bool
		    e struct {
		        x int
		    }
		)
		3.
		名字 := 表达式
		简短模式（short variable declaration）有以下限制：
		定义变量，同时显式初始化。
		不能提供数据类型。
		只能用在函数内部。

		简短变量声明被广泛用于大部分的局部变量的声明和初始化。
		var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。
	*/

	/*
		微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，
		而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。
		因此，如果一个字符串没有结束符\0，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。

		初始化
		var 变量名 类型 = 表达式
		var hp int = 100

		将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。
		var hp = 100
		等号右边的部分在编译原理里被称做右值（rvalue）。

		由于Go语言和C语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。
		Go语言编译器会将小数推导为 float64
	*/
	var attack = 40
	var defence = 20
	var damageRate float32 = 0.17                     // 如果不指定类型，Go语言编译器会将 damageRate 类型推导为 float64
	var damage = float32(attack-defence) * damageRate // 使用 float32() 将结果转换为 float32 类型
	fmt.Println(damage)

	/*
		在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错
	*/
	//conn, err:=net.Dial("tcp", "127.0.0.1:8080")
	//conn1, err:=net.Dial("tcp", "127.0.0.1:8080")

	/*
		变量交换
		在计算机刚发明时，内存非常“精贵”。计算机“大牛”发明了一些算法来避免使用中间变量
		var a int = 100
		var b int = 200
		a = a ^ b
		b = b ^ a
		a = a ^ b
		fmt.Println(a, b)
		这样的算法很多，但是都有一定的数值范围和类型要求。

		多重赋值在Go语言的错误处理和函数返回值中会大量地使用。
	*/
	var testIntSlice IntSlice = []int{1, 2, 3, 4, 5}
	fmt.Println(testIntSlice.Less(3, 1))
	fmt.Println(testIntSlice.Len())
	testIntSlice.Swap(3, 1)
	fmt.Println(testIntSlice)

	/*
		匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。
		任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用

		匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。
		在 Lua 等编程语言里，匿名变量也被叫做哑元变量。
	*/
	a, _ := getData()
	fmt.Println(a)
}

func variable() {
	fmt.Println("==================== variable ====================")
	/*
		函数内定义的变量称为局部变量
		函数外定义的变量称为全局变量
		函数定义中的变量称为形式参数
	*/

	/*
		全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，
		当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

		全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

		Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。
	*/
	fmt.Printf("pi = %f\n", pi) // 全局的
	var pi float32 = 3.0
	fmt.Printf("pi = %f\n", pi) // 局部的

	/*
		在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。
		形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，
		在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。
	*/
}

const codeTemplate = `// Generated by github.com/davyxu/cellnet/
protoc-gen-msg
// DO NOT EDIT!{{range .Protos}}
// Source: {{.Name}}{{end}}
package {{.PackageName}}
{{if gt .TotalMessages 0}}
import (
    "github.com/davyxu/cellnet"
    "reflect"
    _ "github.com/davyxu/cellnet/codec/pb"
)
{{end}}
func init() {
    {{range .Protos}}
    // {{.Name}}{{range .Messages}}
    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}
    {{end}}
}
`

func types() {
	fmt.Println("==================== types ====================")
	/*
		整数类型 int 和 uint，它们分别对应特定 CPU 平台的字长（机器字大小），
		其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。
		大多数情况下，我们只需要 int 一种整型即可，
		它可以用于循环计数器（for 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，
		通常 int 类型的处理速度也是最快的。

		用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。
		同样，byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

		最后，还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。
		uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

		虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。

		Go语言中有符号整数采用 2 的补码形式表示，
		也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2^(n-1) 到 2^(n-1)-1。
		无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2^n-1。

		int8 类型整数的取值范围是从 -128 到 127，而 uint8 类型整数的取值范围是从 0 到 255。
	*/

	/*
		哪些情况下使用 int 和 uint
		程序逻辑对整型范围没有特殊需求。
		例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。
		实际使用中，切片或 map 的元素数量等都可以用 int 来表示。

		反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint。
	*/

	/*
		Go语言提供了两种精度的浮点数 float32 和 float64，
		它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。

		常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
		常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
		float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。

		一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，
		通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。
	*/

	fmt.Println(math.MaxFloat32)
	fmt.Println(math.MaxFloat64)

	var f float32 = 16777216
	fmt.Println(f == f+1) // 累计计算误差很容易扩散

	// 浮点数在声明的时候可以只写整数部分或者小数部分
	const e = .71828
	const one = 1.

	// 很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分
	const Avogadro = 6.02214129e23 // 阿伏伽德罗常数
	const Planck = 6.62606957e-34  // 普朗克常数

	// 用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数
	fmt.Printf("%f\n", math.Pi)
	fmt.Printf("%.2f\n", math.Pi)

	/*
		在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。
		复数的类型有两种，分别是  complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），
		其中 complex128 为复数的默认类型。

		复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。

		声明：
		var name complex128 = complex(x, y)
		name := complex(x, y)

		对于一个复数z := complex(x, y)，
		可以通过Go语言的内置函数real(z) 来获得该复数的实部，也就是 x；
		通过imag(z) 获得该复数的虚部，也就是 y。

		复数也可以用==和!=进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。
		实际操作中建议大家使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数。
	*/
	name := complex(1, 2)
	fmt.Println(name)
	fmt.Println(real(name))
	fmt.Println(imag(name))

	/*
		一个布尔类型的值只有两种：true 或 false

		Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，
		如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。
		如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。
		如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

		布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为
		因此下面的表达式总是安全的
		s != "" && s[0] == 'x'
		其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

		因为&&的优先级比||高（&& 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高）
		下面的布尔表达式可以不加小括号：
		if 'a' <= c && c <= 'z' ||
		    'A' <= c && c <= 'Z' ||
		    '0' <= c && c <= '9' {
		    // ...ASCII字母或数字...
		}

		布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：
		如果需要经常做类似的转换，可以将转换的代码封装成一个函数
		func btoi(b bool) int {
		    if b {
		        return 1
		    }
		    return 0
		}
		数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数
		// itob报告是否为非零。
		func itob(i int) bool { return i != 0 }

		Go语言中不允许将整型强制转换为布尔型
		var n bool
		fmt.Println(int(n) * 2)

		布尔型无法参与数值运算，也无法与其他类型进行转换。
	*/

	/*
		字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

		由于该编码对占用字节长度的不定性，在Go语言中字符串也可能根据需要占用 1 至 4 个字节，
		这与其它编程语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。

		Go语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。
		字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。

		定义字符串，使用双引号""来定义字符串
		\n：换行符
		\r：回车符
		\t：tab 键
		\u 或 \U：Unicode 字符
		\\：反斜杠自身

		字符串 str1 的第 1 个字节：str1[0]
		第 i 个字节：str1[i - 1]
		最后 1 个字节：str1[len(str1)-1]

		这种转换方案只对纯 ASCII 码的字符串有效。
		获取字符串中某个字节的地址属于非法行为，例如 &str1[i]。
	*/
	var str1 = "🍎\n🍌\n🍓\n🍉"
	// 一般的比较运算符（==、!=、<、<=、>=、>）是通过在内存中按字节比较来实现字符串比较的
	fmt.Println(str1)
	fmt.Println(len(str1)) // 字符串所占的字节长度可以通过函数 len() 来获取

	/*
		字符串拼接符“+”
		因为编译器会在行尾自动补全分号，所以拼接字符串用的加号“+”必须放在第一行末尾。
		str1 := "Beginning of the string " +
		"second part of the string"

		Go语言中字符串的内部实现使用 UTF-8 编码，
		通过 rune 类型，可以方便地对每个 UTF-8 字符进行访问。
		当然，Go语言也支持按照传统的 ASCII 码方式逐字符进行访问。

		使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量（string literal），
		这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用`反引号
	*/
	const str2 = `第一行
第二行
第三行\r\n` // 所有的转义字符均无效，文本将会原样输出。
	fmt.Println(str2)

	// 多行字符串一般用于内嵌源码和内嵌数据等

}

func sinImg() {
	fmt.Println("==================== sinImg ====================")
	// 图片大小
	const size = 300
	// 根据给定大小创建灰度图
	// 灰度图是一种常见的图片格式，一般情况下颜色由 8 位组成，灰度范围为 0～255，0 表示黑色，255 表示白色。
	pic := image.NewGray(image.Rect(0, 0, size, size))

	// 遍历每个像素
	for x := 0; x < size; x++ {
		for y := 0; y < size; y++ {
			// 填充为白色
			pic.SetGray(x, y, color.Gray{Y: 255})
		}
	}

	// 从0到最大像素生成x坐标
	for x := 0; x < size; x++ {
		// 让sin的值的范围在0~2Pi之间
		s := float64(x) * 2 * math.Pi / size

		// sin的幅度为一半的像素。向下偏移一半像素并翻转
		y := size/2 - math.Sin(s)*size/2

		// 用黑色绘制sin轨迹
		pic.SetGray(x, int(y), color.Gray{})
	}

	// 创建文件
	file, err := os.Create("sin.png")
	if err != nil {
		log.Fatal(err)
	}
	// 使用png格式将数据写入文件
	png.Encode(file, pic) // 将image信息写入文件中

	// 关闭文件
	file.Close()
}

type IntSlice []int

func (p IntSlice) Len() int {
	return len(p)
}
func (p IntSlice) Less(i, j int) bool {
	return p[i] < p[j]
}
func (p IntSlice) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

func getData() (int, int) {
	return 100, 200
}
